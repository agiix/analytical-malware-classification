import base64

"""
---------------------------------------------------------------------------
            SIGNATURES INDICATING RANSOMWARE BEHAVIOR
---------------------------------------------------------------------------
"""


"""line would be a parsed entry from the onemon json file.
filemod expects an entry of the "*onemon.File" category
and looks for the command key and keywords like 'wmic shadowcopy
delete' or 'vssadmin delete shadows'
Suited for Windows 7 & 10
"""
#userdir: Add a list of user directories, that would indicate that personal user
#files have been modified? (Desktop, Documents, Pictures ....)
fileops = {} 
indicators = []
threshold = 30
def filemod(line):
    if line.get('event', {}).get('kind') == "OpenRead":
        match = "Read"+line.get('event', {}).get('srcpath')
        if match not in fileops:
                fileops[match] = 0
        fileops[match] += 1

    if line.get('event', {}).get('kind') == "OpenModify":
        match = "Modify"+line.get('event', {}).get('srcpath')
        if match not in fileops:
                fileops[match] = 0
        fileops[match] += 1

    if line.get('event', {}).get('kind') == "Rename":
        match = "Rename"+line.get('event', {}).get('srcpath')
        if match not in fileops:
                fileops[match] = 0
        fileops[match] += 1

    if line.get('event', {}).get('kind') == "Delete":
        match = "Delete"+line.get('event', {}).get('srcpath')
        if match not in fileops:
                fileops[match] = 0
        fileops[match] += 1
    
    #If the file has been Read and Modified, the third step usually either includes a renaming of the target file (Ransomware usually adds
    # a new suffix to it) or the target file will be deleted and its original content was either written to another file or it will be lost
    # for good. 
    if "Read"+line.get('event', {}).get('srcpath') and "Modify"+line.get('event', {}).get('srcpath') in fileops:
        if "Rename"+line.get('event', {}).get('srcpath') or "Delete"+line.get('event', {}).get('srcpath') in fileops:
            indicators.append(line.get('event', {}).get('srcpath'))
    
    if len(indicators) > threshold:
        return True
    else:
        return False




"""line would be a parsed entry from the onemon json file.
delshadowcopies expects an entry of the "*onemon.Process" category
and looks for the command key and keywords like 'wmic shadowcopy
delete' or 'vssadmin delete shadows'
Suited for Windows 7 & 10
"""
shadowtoken1 = ["vssadmin","delete","shadows"]
shadowtoken2 = ["wmic","shadowcopy","delete"]
def delshadowcopies(line):
    if all(token in line.get('event', {}).get('command') for token in shadowtoken1):
        return True
    if all(token in line.get('event', {}).get('command') for token in shadowtoken2):
        return True    
    else:
        return False



"""line would be a parsed entry from the onemon json file.
cryptoregistry expects an entry of the "*onemon.Registry" category
and looks for registry queries that check for Microsofts Crptography
library. 
Suited for Windows 7 & 10
"""
reg = "\\REGISTRY\\MACHINE\\SOFTWARE\\WOW6432Node\\Microsoft\\Cryptography"
def crpytoregistry(line):
    if line.get('event', {}).get('kind') == "QueryValueKey" and reg in line.get('event', {}).get('path'):
        return True
    if line.get('event', {}).get('kind') == "OpenKeyEx" and reg in line.get('event', {}).get('path'):
        return True
    if line.get('event', {}).get('kind') == "EnumerateKey" and reg in line.get('event', {}).get('path'):
        return True
    if line.get('event', {}).get('kind') == "QueryKey" and reg in line.get('event', {}).get('path'):
        return True
    else:
        return False



"""
---------------------------------------------------------------------------
            SIGNATURES INDICATING MALWARE BEHAVIOR
---------------------------------------------------------------------------
"""

"""line would be a parsed entry from the onemon json file.
tempexe expects an entry of the "*onemon.Process" category and checks the
command key for executables that launch from temp folders.
Additionally the orig-key will be checked for the value 'False'
Suited for Windows 7 & 10
"""

def tempexe(line):
    if "\\Temp\\" in line.get('event', {}).get('image') and line.get('event', {}).get('orig') == False:
        return True
    else:
        return False





"""
---------------------------------------------------------------------------
                 SIGNATURES NOT SUITED FOR THREEMON
---------------------------------------------------------------------------
"""


"""line would contain a onemon entry of the category "*onemon.FileContents" 
and would be passed to ransomNote for further investigation
ransomwNote checks for "buf", decodes it and looks for certain strings"""

# This matchings are pretty weak, since malware would only need to change
# one character to bypass detection
ransomtokens = (b"encrypted", b"decrypted",
                b"bitcoin", b"decryption", b"encryption")

def ransomNote(line):
    if line.get('event', {}).get('buf') is not None:
        note = base64.b64decode(line.get('event', {}).get('buf'))

        for token in ransomtokens:
            if token in note:
                return True

    return False

event_sigs = {
    "*onemon.FileContents": [ransomNote]
}
