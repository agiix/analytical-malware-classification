#!/usr/bin/env python3

import argparse
import json
import os
import pprint
import socket
import struct

signatures = {
    "performanceregistry": False,
    "checkwmiprvse": False,
    "rsaregistry": False,
    "execdrop": False,
    "doublelaunch": False,
    "wprocmemory": False,
    "malnetflow": False
}

# Array that saves all observed malicious procid's
malprocs = []

"""
---------------------------------------------------------------------------
            SIGNATURES INDICATING EMOTET BEHAVIOR
---------------------------------------------------------------------------
"""

#MITRE TAG = T1060
"""Emotet queries a Windows value called GettickCount which then queries
'\\REGISTRY\\MACHINE\\SYSTEM\\ControlSet001\\Services\\BITS\\Performance' to 
obtain information on how much time has elapsed since the system started, or 
since the Emotet payload launched, as a sort of sanity check. It may use this 
to determine whether it is running in a sandbox, because some sandbox software 
may skip ticks in order to trigger malware that runs with a built-in, timed 
delay before beginning operation.
It additionally queries and sets an int value to a registry key named 
'TaskExecutionCountSinceLastReset', which might seems to be a EMOTET specific
named registry key. 
There is a pattern of queries, which involves exactly 7 different Performance
registry keys as well as the check for TaskExecutionCountSinceLastReset at 
some later point
"""

regperformance = "\\REGISTRY\\MACHINE\\SYSTEM\\ControlSet001\\Services\\BITS\\Performance"
regkeywordcount = "TaskExecutionCountSinceLastReset"
regperformancecount = 0
regperformancethreshold = 7
regkeywordset = False
# Expects line that contains *onemon.Registry kind 
def performanceregistry(line):
    global regperformancecount
    global regkeywordset    
    if line.get('event', {}).get('kind') == "QueryValueKey": 
        if regperformance in line.get('event', {}).get('path'):
            regperformancecount+=1
    if line.get('event', {}).get('kind') == "CreateKeyEx":
        if regperformance in line.get('event', {}).get('path'):
            regperformancecount+=1
    if line.get('event', {}).get('kind') == "SetValueKeyStr":
        if regperformance in line.get('event', {}).get('path'):
            regperformancecount+=1
    if line.get('event', {}).get('kind') == "SetValueKeyInt":
        if regkeywordcount in line.get('event', {}).get('path'):
            regkeywordset = True
    if regperformancecount > 6 and regkeywordset:
        signatures["performanceregistry"] = True
        if line.get('event', {}).get('procid') not in malprocs:
            malprocs.append(line.get('event', {}).get('procid'))


#MITRE TAG = T1047
"""Uses WMI to stealthy execute powershell.exe 
"""
# Expects line that contains *onemon.Process kind
def checkwmiprvse(line):
    if line.get('event', {}).get('command') == "C:\\Windows\\system32\\wbem\\wmiprvse.exe -secured -Embedding":
        signatures["checkwmiprvse"] = True


#MITRE TAG = T1032
"""Emotet is known to use RSA keys for encrypting C2 traffic.
Therefore queries to the following reg key can be observed. 
"""
regRSA = "\\REGISTRY\\MACHINE\\SOFTWARE\\WOW6432Node\\Microsoft\\Cryptography\\Defaults\\Provider\\Microsoft Enhanced RSA and AES Cryptographic Provider"
# Expects line that contains *onemon.Registry kind 
def rsaregistry(line):    
    if line.get('event', {}).get('kind') == "QueryValueKey": 
        if regRSA in line.get('event', {}).get('path'):
            signatures["rsaregistry"] = True


"""Checks if a executable has been dropped and exectued
"""
cuckoolaunch = "C:\\Users\\TFzWCExo\\AppData\\Local\\Temp\\"
# Expects line that contains *onemon.Process kind    
def execdrop(line):
    if cuckoolaunch not in line.get('event', {}).get('image'):
        if line.get('event', {}).get('orig') == False and line.get('event', {}).get('status') == "Create": 
            signatures["execdrop"] = True
            if line.get('event', {}).get('procid') not in malprocs:
                malprocs.append(line.get('event', {}).get('procid'))


"""Checks if the executable get's launched twice, since it is a typical
Emotet behavior to launch a second instance watching over the otherâ€™s back.
The function checks the procid and the parentprocid to confirm that the 
second instance was launched from the first instance. 
"""
launched = [] 
# Expects line that contains *onemon.Process kind
def doublelaunch(line):
    if cuckoolaunch not in line.get('event', {}).get('image'):
        if line.get('event', {}).get('orig') == False and line.get('event', {}).get('status') == "Create": 
            if line.get('event', {}).get('image') in launched:
                signatures["doublelaunch"] = True
            else:
                launched.append(line.get('event', {}).get('image'))

# Expects line that contains *onemon.Suspicious kind
def wprocmemory(line):
    signatures["wprocmemory"] = True
    if line.get('event', {}).get('procid') not in malprocs:
        malprocs.append(line.get('event', {}).get('procid'))

# Expects line that contains *onemon.NetworkFlow kind
netflow = {}
def malnetflow(line):
    if line.get('event', {}).get('procid') in malprocs:
        dstip = socket.inet_ntoa(struct.pack("!I", line.get('event', {}).get('dstip')))
        dstport = line.get('event', {}).get('dstport')
        netflow.update({dstip : dstport})
        signatures["malnetflow"] = True