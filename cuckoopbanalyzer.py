#!/usr/bin/env python3

import argparse
import os
import sys
from pathlib import PurePath
import json
from tabulate import tabulate
from pprint import pprint

import category
from threemon import (
    file_pb2, registry_pb2, suspicious_pb2, inject_pb2, 
    mutant_pb2, notification_pb2, process_pb2, whois_pb2
)
from abstracts import Signature
from threemon import reader
from utils import enumerate_plugins
from report import jsondump, generatepdf

def getprocname(image):
    if "//" in image:
        return image.split("//")[-1]
    elif "\\" in image:
        return image.split("\\")[-1]
    return image

def trimdescription(description):
    length = len(description)
    pos = width
    if length > width:
        while True:
            description = description[:pos] + '\n' + description[pos:]
            length -= width
            pos += width
            if length < width:
                break
    return description


class ProcInfo:

    def __init__(self, proc_event):
        self.proc_event = proc_event

    @property
    def name(self):
        return getprocname(self.proc_event.image).lower()


class ProcessingContext:

    def __init__(self):
        self.procmap = {}

    def add_proc(self, proc_event):
        if proc_event.procid in self.procmap:
            return

        self.procmap[proc_event.procid] = ProcInfo(proc_event)

    def findprocname(self, procid):
        proc = self.procmap.get(procid)
        if not proc:
            return ""

        return proc.name

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("pbfile", type=str, help="Path to a Threemon behavioral log file.")
    parser.add_argument('-pdf', nargs=1, type=str, help="PDF file name")
    parser.add_argument('-json', nargs=1, type=str, help="JSON file name")
    args = parser.parse_args()
    consoleoutput = True
    if args.pdf:
        consoleoutput = False

    width = 73

    pbfilepath = args.pbfile
    if not os.path.isfile(pbfilepath):
        sys.exit("File does not exist.")

    # Processing context holds structures and information used by signatures.
    # IE for procid->process name lookups.
    procctx = ProcessingContext()
    sigs = [
        sig(procctx) for sig in enumerate_plugins("sigs", globals(), Signature)
    ]
    print('\033[2J') 
    print(f"\033[1;30;42mAnalyzing ...\033[1;37;40m\n")

    with open(pbfilepath, "rb") as fp:
        for kind, event in reader.read_events(fp):

            # If it is a process event, add it to the processing context
            if kind == 1:
                procctx.add_proc(event)

            for sig in sigs:
                if isinstance(sig.event_types, list):
                    continue

                if kind not in sig.event_types:
                    continue

                # If sig does not want the subtype, continue.
                subtypes = sig.event_types.get(kind, [])
                if len(subtypes) > 0:
                    if reader.get_subtype(kind, event) not in subtypes:
                        continue

                sig.give_event(kind, event)

    with open('malware-description.json', 'r') as myfile:
        malwaredata=myfile.read()
    malware = json.loads(malwaredata)

    with open('ttps.json', 'r') as ttpfile:
        ttpdata=ttpfile.read()
    ttps = json.loads(ttpdata)

    matchedcategory = []
    for category in category.find_categories(sigs):
        b = []
        b.extend((category,trimdescription(malware[category]['description'])))
        matchedcategory.append(b)
   
    if matchedcategory and consoleoutput:  
        print(f"\n\033[2J\033[1;37;41mThe samples behavior match the following malware categories \033[1;37;40m\n")
        pdtabulate1=lambda test:tabulate(test,headers=["\033[1;31;40mMalware Category","Description\033[1;37;40m"], tablefmt="grid")
        print(pdtabulate1(matchedcategory))
    if not matchedcategory and consoleoutput:
        print(f"\n\033[2J\033[1;37;41mThe samples behavior can not be matched to any malware category \033[1;37;40m\n")

    final = []
    sigsmatched = 0
    matchedttp = {}
    for sig in sigs:
        #a = {}
        multiplettps = False
        #for ttp in sig.TTPS:
        #    if ttp in ttps:
        #        a[ttp] = ttps[ttp]['long']
        if sig.matched:
            sigsmatched += 1
            if len(sig.description):
                sig.description = trimdescription(sig.description)
            for ttp in sig.TTPS:
                b = []
                if ttp not in matchedttp and ttp in ttps:
                    matchedttp[ttp] = ttps[ttp]['long']
                if ttp in ttps and multiplettps:
                    b.extend(("","",ttp,trimdescription(ttps[ttp]['long'])))
                if ttp in ttps and not multiplettps:
                    b.extend((sig.__class__.__name__,sig.description,ttp,trimdescription(ttps[ttp]['long'])))
                    multiplettps = True         
                if ttp == "None":
                    b.extend((sig.__class__.__name__,sig.description,ttp,""))
                final.append(b)       
    if consoleoutput:
        print(f"\n\033[1;37;41mThe following signatures have been triggered\033[1;37;40m\n")
        headers=["\033[1;31;40mSignature", "Description", "TTP", "Description\033[1;37;40m"]
        pdtabulate=lambda test:tabulate(test,headers=headers, tablefmt="grid")
        print(pdtabulate(final))
  
    result = {}

    if matchedcategory:
        result['Categories'] = {}
        for cat in matchedcategory:    
            x = 0
            while x < len(cat):
                result['Categories'][cat[x]] = cat[x+1]
                x += 2
    if not matchedcategory:
        result['Categories'] = "The samples behavior can not be matched to any malware category"

    if matchedttp:
        result['TTPS'] = {}
        result['TTPS'] = matchedttp

    for sig in sigs:
        if sig.matched and sig.events:
            result[sig.__class__.__name__] = {}
            result[sig.__class__.__name__] = sig.events

    if args.pdf:
        generatepdf(sigsmatched,result,final,args.pdf[0])
    if args.json:
        jsondump(result,args.json[0])
