import re

class Signature:

    # Event types holds event kinds+a set of subtypes to filter out events
    # it does not want. Empty set means it will receive all events of the
    # specified kind.
    event_types = {}

    TTPS = []

    name = ""
    description = ""

    def __init__(self, procctx):
        self.procctx = procctx
        self.matched = False

    def init(self):
        pass

    def wants_event(self, event):
        pass

    def trigger(self):
        self.matched = True

    def file_event(self, event):
        pass

    def registry_event(self, event):
        pass

    def process_event(self, event):
        pass
    
    def suspicious_event(self, event):
        pass

    def notification_event(self, event):
        pass

    def inject_event(self, event):
        pass

    def mutant_event(self, event):
        pass

    def thread_event(self, event):
        pass

    def network_event(self, event):
        pass
    
    def vminfo_event(self, event):
        pass

    def mutantevent_event(self, event):
        pass

    def give_event(self, kind, event):
        if kind == 1:
            self.process_event(event)
        elif kind == 2:
            self.registry_event(event)
        elif kind == 3:
            self.suspicious_event(event)
        elif kind == 5:
            self.notification_event(event)
        elif kind == 6:
            self.inject_event(event)
        elif kind == 8:
            self.file_event(event)
        elif kind == 9:
            self.mutant_event(event)
        elif kind == 10:
            self.thread_event(event)
        elif kind == 12:
            self.network_event(event)
        elif kind == 14:
            self.notification_event(event)
        elif kind == 15:
            self.vminfo_event(event)
        elif kind == 16:
            self.mutantevent_event(event)



# _kindmap = {
#     1: process_pb2.Process,
#     2: registry_pb2.Registry,
#     3: suspicious_pb2.Suspicious,
#     5: notification_pb2.Notification,
#     6: inject_pb2.Inject,
#     8: file_pb2.File,
#     9: mutant_pb2.Mutant,
#     10: thread_pb2.ThreadContext,
#     12: network_pb2.NetworkFlow,
#     14: whois_pb2.Whois,
#     15: vminfo_pb2.Vminfo,
#     16: mutant_pb2.Event Skip this one for now
# }


    def check_value(self, pattern, subject, regex=False, all=False):
        """Check a pattern against a given subject.
        @param pattern: string or expression to check for.
        @param subject: target of the check.
        @param regex: boolean representing if the pattern is a regular
                      expression or not and therefore should be compiled.
        @return: boolean with the result of the check.
        """
        ret = set()
        if regex:
            exp = re.compile(pattern, re.IGNORECASE)
            if isinstance(subject, list):
                for item in subject:
                    if exp.match(item):
                        ret.add(item)
            else:
                if exp.match(subject):
                    ret.add(subject)
        else:
            if isinstance(subject, list):
                for item in subject:
                    if item.lower() == pattern.lower():
                        ret.add(item)
            else:
                if subject == pattern:
                    ret.add(subject)

        # Return all elements.
        if all:
            return list(ret)
        # Return only the first element, if available. Otherwise return None.
        elif ret:
            return ret.pop()