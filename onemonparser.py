#!/usr/bin/env python3

import argparse
import os
import sys
from pathlib import PurePath

import category

from abstracts import Signature
from threemon import reader
from utils import enumerate_plugins


def getprocname(image):
    if "//" in image:
        return image.split("//")[-1]
    elif "\\" in image:
        return image.split("\\")[-1]
    return image

class ProcInfo:

    def __init__(self, proc_event):
        self.proc_event = proc_event

    @property
    def name(self):
        return getprocname(self.proc_event.image).lower()


class ProcessingContext:

    def __init__(self):
        self.procmap = {}

    def add_proc(self, proc_event):
        if proc_event.procid in self.procmap:
            return

        self.procmap[proc_event.procid] = ProcInfo(proc_event)

    def findprocname(self, procid):
        proc = self.procmap.get(procid)
        if not proc:
            return ""

        return proc.name

if __name__ == "__main__":

    parser = argparse.ArgumentParser()
    parser.add_argument("pbfile", type=str, help="Path to a Threemon behavioral log file.")
    args = parser.parse_args()

    pbfilepath = args.pbfile
    if not os.path.isfile(pbfilepath):
        sys.exit("File does not exist.")

    # Processing context holds structures and information used by signatures.
    # IE for procid->process name lookups.
    procctx = ProcessingContext()
    sigs = [
        sig(procctx) for sig in enumerate_plugins("sigs", globals(), Signature)
    ]

    with open(pbfilepath, "rb") as fp:
        for kind, event in reader.read_events(fp):

            # If it is a process event, add it to the processing context
            if kind == 1:
                procctx.add_proc(event)

            for sig in sigs:
                if isinstance(sig.event_types, list):
                    continue

                if kind not in sig.event_types:
                    continue

                # If sig does not want the subtype, continue.
                subtypes = sig.event_types.get(kind, [])
                if len(subtypes) > 0:
                    if reader.get_subtype(kind, event) not in subtypes:
                        continue

                sig.give_event(kind, event)

    for sig in sigs:
        if sig.matched:
            print(
                f"Signature triggered: '{sig.__class__.__name__}'. "
                f"{sig.description}"
            )

    for category in category.find_categories(sigs):
        print(f"Determined category: {category}")
